from __future__ import annotations

from decimal import Decimal
from pathlib import Path

import pandas as pd

from pipeline.transform import SeedFrames


def _to_sql_literal(value: object) -> str:
    if pd.isna(value):
        return "NULL"
    if isinstance(value, bool):
        return "TRUE" if value else "FALSE"
    if isinstance(value, int):
        return str(value)
    if isinstance(value, float):
        return str(Decimal(str(value)).normalize())

    escaped = str(value).replace("'", "''")
    return f"'{escaped}'"


def _render_insert_block(
    table: str,
    columns: list[str],
    frame: pd.DataFrame,
    *,
    batch_size: int = 500,
) -> str:
    if frame.empty:
        return ""

    values = [
        f"({', '.join(_to_sql_literal(value) for value in row)})"
        for row in frame[columns].itertuples(index=False, name=None)
    ]

    blocks: list[str] = []
    for idx in range(0, len(values), batch_size):
        chunk = values[idx : idx + batch_size]
        blocks.append(
            "INSERT INTO "
            f"{table} ({', '.join(columns)})\nVALUES\n"
            + ",\n".join(chunk)
            + "\nON CONFLICT DO NOTHING;\n"
        )
    return "\n".join(blocks)


def render_seed_sql(seed_frames: SeedFrames, schedules_sql: str | None = None) -> str:
    truncate_order = ", ".join(
        [
            "flight_schedules",
            "route_metrics",
            "routes",
            "aircraft_types",
            "airports",
            "airlines",
        ]
    )

    parts = [
        "-- Auto-generated by pipeline.cli generate-seeds",
        "BEGIN;",
        f"TRUNCATE TABLE {truncate_order} CASCADE;",
        _render_insert_block(
            "airlines",
            [
                "airline_id",
                "name",
                "iata_code",
                "icao_code",
                "call_sign",
                "country",
                "is_active",
            ],
            seed_frames.airlines,
        ),
        _render_insert_block(
            "airports",
            [
                "airport_id",
                "name",
                "city",
                "country",
                "iata_code",
                "icao_code",
                "latitude",
                "longitude",
                "timezone",
                "database_timezone",
                "type",
            ],
            seed_frames.airports,
        ),
        _render_insert_block(
            "aircraft_types",
            [
                "plane_iso",
                "plane_name",
                "aircraft_name",
                "manufacturer",
                "category",
                "fuel_litre_per_100km_per_passenger",
                "capacity_min",
                "capacity_max",
                "range_nm",
                "co2_g_per_pax_mile",
            ],
            seed_frames.aircraft_types,
        ),
        _render_insert_block(
            "routes",
            [
                "route_id",
                "airline_id",
                "source_airport_id",
                "destination_airport_id",
                "stops",
                "plane_iso",
            ],
            seed_frames.routes,
        ),
        _render_insert_block(
            "route_metrics",
            [
                "route_id",
                "distance_km",
                "distance_miles",
                "is_international",
                "co2_total_kg",
            ],
            seed_frames.route_metrics,
        ),
    ]

    if schedules_sql:
        parts.append("-- Flight schedules appended from deterministic SQL source")
        parts.append(schedules_sql.strip())

    parts.extend(["COMMIT;", ""])
    return "\n".join(part for part in parts if part is not None)


def load_optional_schedules_sql(path: Path | None) -> str | None:
    if path is None or not path.exists():
        return None
    return path.read_text(encoding="utf-8")
